// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: externalgrpc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Any } from "./google/protobuf/any.ts";
import { Node, Pod } from "./k8s.io/api/core/v1/generated.ts";
import { Duration, Time } from "./k8s.io/apimachinery/pkg/apis/meta/v1/generated.ts";

export const protobufPackage = "clusterautoscaler.cloudprovider.v1.externalgrpc";

export interface NodeGroup {
  /** ID of the node group on the cloud provider. */
  id: string;
  /** MinSize of the node group on the cloud provider. */
  minSize: number;
  /** MaxSize of the node group on the cloud provider. */
  maxSize: number;
  /** Debug returns a string containing all information regarding this node group. */
  debug: string;
}

export interface ExternalGrpcNode {
  /** ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>. */
  providerID: string;
  /** Name of the node assigned by the cloud provider. */
  name: string;
  /** labels is a map of {key,value} pairs with the node's labels. */
  labels: { [key: string]: string };
  /** If specified, the node's annotations. */
  annotations: { [key: string]: string };
}

export interface ExternalGrpcNode_LabelsEntry {
  key: string;
  value: string;
}

export interface ExternalGrpcNode_AnnotationsEntry {
  key: string;
  value: string;
}

/** Intentionally empty. */
export interface NodeGroupsRequest {
}

export interface NodeGroupsResponse {
  /** All the node groups that the cloud provider service supports. */
  nodeGroups: NodeGroup[];
}

export interface NodeGroupForNodeRequest {
  /** Node for which the request is performed. */
  node: ExternalGrpcNode | undefined;
}

export interface NodeGroupForNodeResponse {
  /** Node group for the given node. nodeGroup with id = "" means no node group. */
  nodeGroup: NodeGroup | undefined;
}

export interface PricingNodePriceRequest {
  /** Node for which the request is performed. */
  node:
    | ExternalGrpcNode
    | undefined;
  /** Start time for the request period. */
  startTime:
    | Time
    | undefined;
  /** End time for the request period. */
  endTime: Time | undefined;
}

export interface PricingNodePriceResponse {
  /** Theoretical minimum price of running a node for a given period. */
  price: number;
}

export interface PricingPodPriceRequest {
  /** Pod for which the request is performed. */
  pod:
    | Pod
    | undefined;
  /** Start time for the request period. */
  startTime:
    | Time
    | undefined;
  /** End time for the request period. */
  endTime: Time | undefined;
}

export interface PricingPodPriceResponse {
  /** Theoretical minimum price of running a pod for a given period. */
  price: number;
}

/** Intentionally empty. */
export interface GPULabelRequest {
}

export interface GPULabelResponse {
  /** Label added to nodes with a GPU resource. */
  label: string;
}

/** Intentionally empty. */
export interface GetAvailableGPUTypesRequest {
}

export interface GetAvailableGPUTypesResponse {
  /** GPU types passed in as opaque key-value pairs. */
  gpuTypes: { [key: string]: Any };
}

export interface GetAvailableGPUTypesResponse_GpuTypesEntry {
  key: string;
  value: Any | undefined;
}

/** Intentionally empty. */
export interface CleanupRequest {
}

/** Intentionally empty. */
export interface CleanupResponse {
}

/** Intentionally empty. */
export interface RefreshRequest {
}

/** Intentionally empty. */
export interface RefreshResponse {
}

export interface NodeGroupTargetSizeRequest {
  /** ID of the node group for the request. */
  id: string;
}

export interface NodeGroupTargetSizeResponse {
  /** Current target size of the node group. */
  targetSize: number;
}

export interface NodeGroupIncreaseSizeRequest {
  /** Number of nodes to add. */
  delta: number;
  /** ID of the node group for the request. */
  id: string;
}

/** Intentionally empty. */
export interface NodeGroupIncreaseSizeResponse {
}

export interface NodeGroupDeleteNodesRequest {
  /** List of nodes to delete. */
  nodes: ExternalGrpcNode[];
  /** ID of the node group for the request. */
  id: string;
}

/** Intentionally empty. */
export interface NodeGroupDeleteNodesResponse {
}

export interface NodeGroupDecreaseTargetSizeRequest {
  /** Number of nodes to delete. */
  delta: number;
  /** ID of the node group for the request. */
  id: string;
}

/** Intentionally empty. */
export interface NodeGroupDecreaseTargetSizeResponse {
}

export interface NodeGroupNodesRequest {
  /** ID of the node group for the request. */
  id: string;
}

export interface NodeGroupNodesResponse {
  /** list of cloud provider instances in a node group. */
  instances: Instance[];
}

export interface Instance {
  /** Id of the instance. */
  id: string;
  /** Status of the node. */
  status: InstanceStatus | undefined;
}

/** InstanceStatus represents the instance status. */
export interface InstanceStatus {
  /** InstanceState tells if the instance is running, being created or being deleted. */
  instanceState: InstanceStatus_InstanceState;
  /**
   * ErrorInfo provides information about the error status.
   * If there is no error condition related to instance, then errorInfo.errorCode should be an empty string.
   */
  errorInfo: InstanceErrorInfo | undefined;
}

export enum InstanceStatus_InstanceState {
  /** unspecified - an Unspecified instanceState means the actual instance status is undefined (nil). */
  unspecified = 0,
  /** instanceRunning - InstanceRunning means instance is running. */
  instanceRunning = 1,
  /** instanceCreating - InstanceCreating means instance is being created. */
  instanceCreating = 2,
  /** instanceDeleting - InstanceDeleting means instance is being deleted. */
  instanceDeleting = 3,
  UNRECOGNIZED = -1,
}

export function instanceStatus_InstanceStateFromJSON(object: any): InstanceStatus_InstanceState {
  switch (object) {
    case 0:
    case "unspecified":
      return InstanceStatus_InstanceState.unspecified;
    case 1:
    case "instanceRunning":
      return InstanceStatus_InstanceState.instanceRunning;
    case 2:
    case "instanceCreating":
      return InstanceStatus_InstanceState.instanceCreating;
    case 3:
    case "instanceDeleting":
      return InstanceStatus_InstanceState.instanceDeleting;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstanceStatus_InstanceState.UNRECOGNIZED;
  }
}

export function instanceStatus_InstanceStateToJSON(object: InstanceStatus_InstanceState): string {
  switch (object) {
    case InstanceStatus_InstanceState.unspecified:
      return "unspecified";
    case InstanceStatus_InstanceState.instanceRunning:
      return "instanceRunning";
    case InstanceStatus_InstanceState.instanceCreating:
      return "instanceCreating";
    case InstanceStatus_InstanceState.instanceDeleting:
      return "instanceDeleting";
    case InstanceStatus_InstanceState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** InstanceErrorInfo provides information about error condition on instance. */
export interface InstanceErrorInfo {
  /**
   * ErrorCode is cloud-provider specific error code for error condition.
   * An empty string for errorCode means there is no errorInfo for the instance (nil).
   */
  errorCode: string;
  /** ErrorMessage is the human readable description of error condition. */
  errorMessage: string;
  /** InstanceErrorClass defines the class of error condition. */
  instanceErrorClass: number;
}

export interface NodeGroupTemplateNodeInfoRequest {
  /** ID of the node group for the request. */
  id: string;
}

export interface NodeGroupTemplateNodeInfoResponse {
  /** nodeInfo is the extracted data from the cloud provider, as a primitive Kubernetes Node type. */
  nodeInfo: Node | undefined;
}

export interface NodeGroupAutoscalingOptions {
  /**
   * ScaleDownUtilizationThreshold sets threshold for nodes to be considered for scale down
   * if cpu or memory utilization is over threshold.
   */
  scaleDownUtilizationThreshold: number;
  /**
   * ScaleDownGpuUtilizationThreshold sets threshold for gpu nodes to be
   * considered for scale down if gpu utilization is over threshold.
   */
  scaleDownGpuUtilizationThreshold: number;
  /**
   * ScaleDownUnneededTime sets the duration CA expects a node to be
   * unneeded/eligible for removal before scaling down the node.
   */
  scaleDownUnneededTime:
    | Duration
    | undefined;
  /**
   * ScaleDownUnreadyTime represents how long an unready node should be
   * unneeded before it is eligible for scale down.
   */
  scaleDownUnreadyTime:
    | Duration
    | undefined;
  /** MaxNodeProvisionTime time CA waits for node to be provisioned */
  MaxNodeProvisionTime:
    | Duration
    | undefined;
  /** ZeroOrMaxNodeScaling means that a node group should be scaled up to maximum size or down to zero nodes all at once instead of one-by-one. */
  zeroOrMaxNodeScaling: boolean;
  /** IgnoreDaemonSetsUtilization sets if daemonsets utilization should be considered during node scale-down */
  ignoreDaemonSetsUtilization: boolean;
}

export interface NodeGroupAutoscalingOptionsRequest {
  /** ID of the node group for the request. */
  id: string;
  /** default node group autoscaling options. */
  defaults: NodeGroupAutoscalingOptions | undefined;
}

export interface NodeGroupAutoscalingOptionsResponse {
  /** autoscaling options for the requested node. */
  nodeGroupAutoscalingOptions: NodeGroupAutoscalingOptions | undefined;
}

function createBaseNodeGroup(): NodeGroup {
  return { id: "", minSize: 0, maxSize: 0, debug: "" };
}

export const NodeGroup: MessageFns<NodeGroup> = {
  encode(message: NodeGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.minSize !== 0) {
      writer.uint32(16).int32(message.minSize);
    }
    if (message.maxSize !== 0) {
      writer.uint32(24).int32(message.maxSize);
    }
    if (message.debug !== "") {
      writer.uint32(34).string(message.debug);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.debug = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroup {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      minSize: isSet(object.minSize) ? globalThis.Number(object.minSize) : 0,
      maxSize: isSet(object.maxSize) ? globalThis.Number(object.maxSize) : 0,
      debug: isSet(object.debug) ? globalThis.String(object.debug) : "",
    };
  },

  toJSON(message: NodeGroup): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.minSize !== 0) {
      obj.minSize = Math.round(message.minSize);
    }
    if (message.maxSize !== 0) {
      obj.maxSize = Math.round(message.maxSize);
    }
    if (message.debug !== "") {
      obj.debug = message.debug;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroup>, I>>(base?: I): NodeGroup {
    return NodeGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroup>, I>>(object: I): NodeGroup {
    const message = createBaseNodeGroup();
    message.id = object.id ?? "";
    message.minSize = object.minSize ?? 0;
    message.maxSize = object.maxSize ?? 0;
    message.debug = object.debug ?? "";
    return message;
  },
};

function createBaseExternalGrpcNode(): ExternalGrpcNode {
  return { providerID: "", name: "", labels: {}, annotations: {} };
}

export const ExternalGrpcNode: MessageFns<ExternalGrpcNode> = {
  encode(message: ExternalGrpcNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerID !== "") {
      writer.uint32(10).string(message.providerID);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ExternalGrpcNode_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      ExternalGrpcNode_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalGrpcNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalGrpcNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ExternalGrpcNode_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ExternalGrpcNode_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.annotations[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalGrpcNode {
    return {
      providerID: isSet(object.providerID) ? globalThis.String(object.providerID) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ExternalGrpcNode): unknown {
    const obj: any = {};
    if (message.providerID !== "") {
      obj.providerID = message.providerID;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExternalGrpcNode>, I>>(base?: I): ExternalGrpcNode {
    return ExternalGrpcNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExternalGrpcNode>, I>>(object: I): ExternalGrpcNode {
    const message = createBaseExternalGrpcNode();
    message.providerID = object.providerID ?? "";
    message.name = object.name ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseExternalGrpcNode_LabelsEntry(): ExternalGrpcNode_LabelsEntry {
  return { key: "", value: "" };
}

export const ExternalGrpcNode_LabelsEntry: MessageFns<ExternalGrpcNode_LabelsEntry> = {
  encode(message: ExternalGrpcNode_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalGrpcNode_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalGrpcNode_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalGrpcNode_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ExternalGrpcNode_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExternalGrpcNode_LabelsEntry>, I>>(base?: I): ExternalGrpcNode_LabelsEntry {
    return ExternalGrpcNode_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExternalGrpcNode_LabelsEntry>, I>>(object: I): ExternalGrpcNode_LabelsEntry {
    const message = createBaseExternalGrpcNode_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExternalGrpcNode_AnnotationsEntry(): ExternalGrpcNode_AnnotationsEntry {
  return { key: "", value: "" };
}

export const ExternalGrpcNode_AnnotationsEntry: MessageFns<ExternalGrpcNode_AnnotationsEntry> = {
  encode(message: ExternalGrpcNode_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalGrpcNode_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalGrpcNode_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalGrpcNode_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ExternalGrpcNode_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExternalGrpcNode_AnnotationsEntry>, I>>(
    base?: I,
  ): ExternalGrpcNode_AnnotationsEntry {
    return ExternalGrpcNode_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExternalGrpcNode_AnnotationsEntry>, I>>(
    object: I,
  ): ExternalGrpcNode_AnnotationsEntry {
    const message = createBaseExternalGrpcNode_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNodeGroupsRequest(): NodeGroupsRequest {
  return {};
}

export const NodeGroupsRequest: MessageFns<NodeGroupsRequest> = {
  encode(_: NodeGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NodeGroupsRequest {
    return {};
  },

  toJSON(_: NodeGroupsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupsRequest>, I>>(base?: I): NodeGroupsRequest {
    return NodeGroupsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupsRequest>, I>>(_: I): NodeGroupsRequest {
    const message = createBaseNodeGroupsRequest();
    return message;
  },
};

function createBaseNodeGroupsResponse(): NodeGroupsResponse {
  return { nodeGroups: [] };
}

export const NodeGroupsResponse: MessageFns<NodeGroupsResponse> = {
  encode(message: NodeGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeGroups) {
      NodeGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeGroups.push(NodeGroup.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupsResponse {
    return {
      nodeGroups: globalThis.Array.isArray(object?.nodeGroups)
        ? object.nodeGroups.map((e: any) => NodeGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NodeGroupsResponse): unknown {
    const obj: any = {};
    if (message.nodeGroups?.length) {
      obj.nodeGroups = message.nodeGroups.map((e) => NodeGroup.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupsResponse>, I>>(base?: I): NodeGroupsResponse {
    return NodeGroupsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupsResponse>, I>>(object: I): NodeGroupsResponse {
    const message = createBaseNodeGroupsResponse();
    message.nodeGroups = object.nodeGroups?.map((e) => NodeGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNodeGroupForNodeRequest(): NodeGroupForNodeRequest {
  return { node: undefined };
}

export const NodeGroupForNodeRequest: MessageFns<NodeGroupForNodeRequest> = {
  encode(message: NodeGroupForNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      ExternalGrpcNode.encode(message.node, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupForNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupForNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = ExternalGrpcNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupForNodeRequest {
    return { node: isSet(object.node) ? ExternalGrpcNode.fromJSON(object.node) : undefined };
  },

  toJSON(message: NodeGroupForNodeRequest): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = ExternalGrpcNode.toJSON(message.node);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupForNodeRequest>, I>>(base?: I): NodeGroupForNodeRequest {
    return NodeGroupForNodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupForNodeRequest>, I>>(object: I): NodeGroupForNodeRequest {
    const message = createBaseNodeGroupForNodeRequest();
    message.node = (object.node !== undefined && object.node !== null)
      ? ExternalGrpcNode.fromPartial(object.node)
      : undefined;
    return message;
  },
};

function createBaseNodeGroupForNodeResponse(): NodeGroupForNodeResponse {
  return { nodeGroup: undefined };
}

export const NodeGroupForNodeResponse: MessageFns<NodeGroupForNodeResponse> = {
  encode(message: NodeGroupForNodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeGroup !== undefined) {
      NodeGroup.encode(message.nodeGroup, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupForNodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupForNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeGroup = NodeGroup.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupForNodeResponse {
    return { nodeGroup: isSet(object.nodeGroup) ? NodeGroup.fromJSON(object.nodeGroup) : undefined };
  },

  toJSON(message: NodeGroupForNodeResponse): unknown {
    const obj: any = {};
    if (message.nodeGroup !== undefined) {
      obj.nodeGroup = NodeGroup.toJSON(message.nodeGroup);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupForNodeResponse>, I>>(base?: I): NodeGroupForNodeResponse {
    return NodeGroupForNodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupForNodeResponse>, I>>(object: I): NodeGroupForNodeResponse {
    const message = createBaseNodeGroupForNodeResponse();
    message.nodeGroup = (object.nodeGroup !== undefined && object.nodeGroup !== null)
      ? NodeGroup.fromPartial(object.nodeGroup)
      : undefined;
    return message;
  },
};

function createBasePricingNodePriceRequest(): PricingNodePriceRequest {
  return { node: undefined, startTime: undefined, endTime: undefined };
}

export const PricingNodePriceRequest: MessageFns<PricingNodePriceRequest> = {
  encode(message: PricingNodePriceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      ExternalGrpcNode.encode(message.node, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== undefined) {
      Time.encode(message.startTime, writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Time.encode(message.endTime, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricingNodePriceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricingNodePriceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = ExternalGrpcNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startTime = Time.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endTime = Time.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PricingNodePriceRequest {
    return {
      node: isSet(object.node) ? ExternalGrpcNode.fromJSON(object.node) : undefined,
      startTime: isSet(object.startTime) ? Time.fromJSON(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? Time.fromJSON(object.endTime) : undefined,
    };
  },

  toJSON(message: PricingNodePriceRequest): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = ExternalGrpcNode.toJSON(message.node);
    }
    if (message.startTime !== undefined) {
      obj.startTime = Time.toJSON(message.startTime);
    }
    if (message.endTime !== undefined) {
      obj.endTime = Time.toJSON(message.endTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PricingNodePriceRequest>, I>>(base?: I): PricingNodePriceRequest {
    return PricingNodePriceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PricingNodePriceRequest>, I>>(object: I): PricingNodePriceRequest {
    const message = createBasePricingNodePriceRequest();
    message.node = (object.node !== undefined && object.node !== null)
      ? ExternalGrpcNode.fromPartial(object.node)
      : undefined;
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Time.fromPartial(object.startTime)
      : undefined;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? Time.fromPartial(object.endTime)
      : undefined;
    return message;
  },
};

function createBasePricingNodePriceResponse(): PricingNodePriceResponse {
  return { price: 0 };
}

export const PricingNodePriceResponse: MessageFns<PricingNodePriceResponse> = {
  encode(message: PricingNodePriceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.price !== 0) {
      writer.uint32(9).double(message.price);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricingNodePriceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricingNodePriceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.price = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PricingNodePriceResponse {
    return { price: isSet(object.price) ? globalThis.Number(object.price) : 0 };
  },

  toJSON(message: PricingNodePriceResponse): unknown {
    const obj: any = {};
    if (message.price !== 0) {
      obj.price = message.price;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PricingNodePriceResponse>, I>>(base?: I): PricingNodePriceResponse {
    return PricingNodePriceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PricingNodePriceResponse>, I>>(object: I): PricingNodePriceResponse {
    const message = createBasePricingNodePriceResponse();
    message.price = object.price ?? 0;
    return message;
  },
};

function createBasePricingPodPriceRequest(): PricingPodPriceRequest {
  return { pod: undefined, startTime: undefined, endTime: undefined };
}

export const PricingPodPriceRequest: MessageFns<PricingPodPriceRequest> = {
  encode(message: PricingPodPriceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pod !== undefined) {
      Pod.encode(message.pod, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== undefined) {
      Time.encode(message.startTime, writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Time.encode(message.endTime, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricingPodPriceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricingPodPriceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pod = Pod.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startTime = Time.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endTime = Time.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PricingPodPriceRequest {
    return {
      pod: isSet(object.pod) ? Pod.fromJSON(object.pod) : undefined,
      startTime: isSet(object.startTime) ? Time.fromJSON(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? Time.fromJSON(object.endTime) : undefined,
    };
  },

  toJSON(message: PricingPodPriceRequest): unknown {
    const obj: any = {};
    if (message.pod !== undefined) {
      obj.pod = Pod.toJSON(message.pod);
    }
    if (message.startTime !== undefined) {
      obj.startTime = Time.toJSON(message.startTime);
    }
    if (message.endTime !== undefined) {
      obj.endTime = Time.toJSON(message.endTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PricingPodPriceRequest>, I>>(base?: I): PricingPodPriceRequest {
    return PricingPodPriceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PricingPodPriceRequest>, I>>(object: I): PricingPodPriceRequest {
    const message = createBasePricingPodPriceRequest();
    message.pod = (object.pod !== undefined && object.pod !== null) ? Pod.fromPartial(object.pod) : undefined;
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Time.fromPartial(object.startTime)
      : undefined;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? Time.fromPartial(object.endTime)
      : undefined;
    return message;
  },
};

function createBasePricingPodPriceResponse(): PricingPodPriceResponse {
  return { price: 0 };
}

export const PricingPodPriceResponse: MessageFns<PricingPodPriceResponse> = {
  encode(message: PricingPodPriceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.price !== 0) {
      writer.uint32(9).double(message.price);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricingPodPriceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricingPodPriceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.price = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PricingPodPriceResponse {
    return { price: isSet(object.price) ? globalThis.Number(object.price) : 0 };
  },

  toJSON(message: PricingPodPriceResponse): unknown {
    const obj: any = {};
    if (message.price !== 0) {
      obj.price = message.price;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PricingPodPriceResponse>, I>>(base?: I): PricingPodPriceResponse {
    return PricingPodPriceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PricingPodPriceResponse>, I>>(object: I): PricingPodPriceResponse {
    const message = createBasePricingPodPriceResponse();
    message.price = object.price ?? 0;
    return message;
  },
};

function createBaseGPULabelRequest(): GPULabelRequest {
  return {};
}

export const GPULabelRequest: MessageFns<GPULabelRequest> = {
  encode(_: GPULabelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GPULabelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGPULabelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GPULabelRequest {
    return {};
  },

  toJSON(_: GPULabelRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GPULabelRequest>, I>>(base?: I): GPULabelRequest {
    return GPULabelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GPULabelRequest>, I>>(_: I): GPULabelRequest {
    const message = createBaseGPULabelRequest();
    return message;
  },
};

function createBaseGPULabelResponse(): GPULabelResponse {
  return { label: "" };
}

export const GPULabelResponse: MessageFns<GPULabelResponse> = {
  encode(message: GPULabelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GPULabelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGPULabelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GPULabelResponse {
    return { label: isSet(object.label) ? globalThis.String(object.label) : "" };
  },

  toJSON(message: GPULabelResponse): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GPULabelResponse>, I>>(base?: I): GPULabelResponse {
    return GPULabelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GPULabelResponse>, I>>(object: I): GPULabelResponse {
    const message = createBaseGPULabelResponse();
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseGetAvailableGPUTypesRequest(): GetAvailableGPUTypesRequest {
  return {};
}

export const GetAvailableGPUTypesRequest: MessageFns<GetAvailableGPUTypesRequest> = {
  encode(_: GetAvailableGPUTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableGPUTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableGPUTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAvailableGPUTypesRequest {
    return {};
  },

  toJSON(_: GetAvailableGPUTypesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAvailableGPUTypesRequest>, I>>(base?: I): GetAvailableGPUTypesRequest {
    return GetAvailableGPUTypesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAvailableGPUTypesRequest>, I>>(_: I): GetAvailableGPUTypesRequest {
    const message = createBaseGetAvailableGPUTypesRequest();
    return message;
  },
};

function createBaseGetAvailableGPUTypesResponse(): GetAvailableGPUTypesResponse {
  return { gpuTypes: {} };
}

export const GetAvailableGPUTypesResponse: MessageFns<GetAvailableGPUTypesResponse> = {
  encode(message: GetAvailableGPUTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.gpuTypes).forEach(([key, value]) => {
      GetAvailableGPUTypesResponse_GpuTypesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableGPUTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableGPUTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetAvailableGPUTypesResponse_GpuTypesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.gpuTypes[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAvailableGPUTypesResponse {
    return {
      gpuTypes: isObject(object.gpuTypes)
        ? Object.entries(object.gpuTypes).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetAvailableGPUTypesResponse): unknown {
    const obj: any = {};
    if (message.gpuTypes) {
      const entries = Object.entries(message.gpuTypes);
      if (entries.length > 0) {
        obj.gpuTypes = {};
        entries.forEach(([k, v]) => {
          obj.gpuTypes[k] = Any.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAvailableGPUTypesResponse>, I>>(base?: I): GetAvailableGPUTypesResponse {
    return GetAvailableGPUTypesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAvailableGPUTypesResponse>, I>>(object: I): GetAvailableGPUTypesResponse {
    const message = createBaseGetAvailableGPUTypesResponse();
    message.gpuTypes = Object.entries(object.gpuTypes ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetAvailableGPUTypesResponse_GpuTypesEntry(): GetAvailableGPUTypesResponse_GpuTypesEntry {
  return { key: "", value: undefined };
}

export const GetAvailableGPUTypesResponse_GpuTypesEntry: MessageFns<GetAvailableGPUTypesResponse_GpuTypesEntry> = {
  encode(message: GetAvailableGPUTypesResponse_GpuTypesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableGPUTypesResponse_GpuTypesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableGPUTypesResponse_GpuTypesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAvailableGPUTypesResponse_GpuTypesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetAvailableGPUTypesResponse_GpuTypesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAvailableGPUTypesResponse_GpuTypesEntry>, I>>(
    base?: I,
  ): GetAvailableGPUTypesResponse_GpuTypesEntry {
    return GetAvailableGPUTypesResponse_GpuTypesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAvailableGPUTypesResponse_GpuTypesEntry>, I>>(
    object: I,
  ): GetAvailableGPUTypesResponse_GpuTypesEntry {
    const message = createBaseGetAvailableGPUTypesResponse_GpuTypesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseCleanupRequest(): CleanupRequest {
  return {};
}

export const CleanupRequest: MessageFns<CleanupRequest> = {
  encode(_: CleanupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CleanupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCleanupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CleanupRequest {
    return {};
  },

  toJSON(_: CleanupRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CleanupRequest>, I>>(base?: I): CleanupRequest {
    return CleanupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CleanupRequest>, I>>(_: I): CleanupRequest {
    const message = createBaseCleanupRequest();
    return message;
  },
};

function createBaseCleanupResponse(): CleanupResponse {
  return {};
}

export const CleanupResponse: MessageFns<CleanupResponse> = {
  encode(_: CleanupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CleanupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCleanupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CleanupResponse {
    return {};
  },

  toJSON(_: CleanupResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CleanupResponse>, I>>(base?: I): CleanupResponse {
    return CleanupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CleanupResponse>, I>>(_: I): CleanupResponse {
    const message = createBaseCleanupResponse();
    return message;
  },
};

function createBaseRefreshRequest(): RefreshRequest {
  return {};
}

export const RefreshRequest: MessageFns<RefreshRequest> = {
  encode(_: RefreshRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RefreshRequest {
    return {};
  },

  toJSON(_: RefreshRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshRequest>, I>>(base?: I): RefreshRequest {
    return RefreshRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshRequest>, I>>(_: I): RefreshRequest {
    const message = createBaseRefreshRequest();
    return message;
  },
};

function createBaseRefreshResponse(): RefreshResponse {
  return {};
}

export const RefreshResponse: MessageFns<RefreshResponse> = {
  encode(_: RefreshResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RefreshResponse {
    return {};
  },

  toJSON(_: RefreshResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshResponse>, I>>(base?: I): RefreshResponse {
    return RefreshResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshResponse>, I>>(_: I): RefreshResponse {
    const message = createBaseRefreshResponse();
    return message;
  },
};

function createBaseNodeGroupTargetSizeRequest(): NodeGroupTargetSizeRequest {
  return { id: "" };
}

export const NodeGroupTargetSizeRequest: MessageFns<NodeGroupTargetSizeRequest> = {
  encode(message: NodeGroupTargetSizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupTargetSizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupTargetSizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupTargetSizeRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: NodeGroupTargetSizeRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupTargetSizeRequest>, I>>(base?: I): NodeGroupTargetSizeRequest {
    return NodeGroupTargetSizeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupTargetSizeRequest>, I>>(object: I): NodeGroupTargetSizeRequest {
    const message = createBaseNodeGroupTargetSizeRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNodeGroupTargetSizeResponse(): NodeGroupTargetSizeResponse {
  return { targetSize: 0 };
}

export const NodeGroupTargetSizeResponse: MessageFns<NodeGroupTargetSizeResponse> = {
  encode(message: NodeGroupTargetSizeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetSize !== 0) {
      writer.uint32(8).int32(message.targetSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupTargetSizeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupTargetSizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.targetSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupTargetSizeResponse {
    return { targetSize: isSet(object.targetSize) ? globalThis.Number(object.targetSize) : 0 };
  },

  toJSON(message: NodeGroupTargetSizeResponse): unknown {
    const obj: any = {};
    if (message.targetSize !== 0) {
      obj.targetSize = Math.round(message.targetSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupTargetSizeResponse>, I>>(base?: I): NodeGroupTargetSizeResponse {
    return NodeGroupTargetSizeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupTargetSizeResponse>, I>>(object: I): NodeGroupTargetSizeResponse {
    const message = createBaseNodeGroupTargetSizeResponse();
    message.targetSize = object.targetSize ?? 0;
    return message;
  },
};

function createBaseNodeGroupIncreaseSizeRequest(): NodeGroupIncreaseSizeRequest {
  return { delta: 0, id: "" };
}

export const NodeGroupIncreaseSizeRequest: MessageFns<NodeGroupIncreaseSizeRequest> = {
  encode(message: NodeGroupIncreaseSizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delta !== 0) {
      writer.uint32(8).int32(message.delta);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupIncreaseSizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupIncreaseSizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.delta = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupIncreaseSizeRequest {
    return {
      delta: isSet(object.delta) ? globalThis.Number(object.delta) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: NodeGroupIncreaseSizeRequest): unknown {
    const obj: any = {};
    if (message.delta !== 0) {
      obj.delta = Math.round(message.delta);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupIncreaseSizeRequest>, I>>(base?: I): NodeGroupIncreaseSizeRequest {
    return NodeGroupIncreaseSizeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupIncreaseSizeRequest>, I>>(object: I): NodeGroupIncreaseSizeRequest {
    const message = createBaseNodeGroupIncreaseSizeRequest();
    message.delta = object.delta ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNodeGroupIncreaseSizeResponse(): NodeGroupIncreaseSizeResponse {
  return {};
}

export const NodeGroupIncreaseSizeResponse: MessageFns<NodeGroupIncreaseSizeResponse> = {
  encode(_: NodeGroupIncreaseSizeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupIncreaseSizeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupIncreaseSizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NodeGroupIncreaseSizeResponse {
    return {};
  },

  toJSON(_: NodeGroupIncreaseSizeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupIncreaseSizeResponse>, I>>(base?: I): NodeGroupIncreaseSizeResponse {
    return NodeGroupIncreaseSizeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupIncreaseSizeResponse>, I>>(_: I): NodeGroupIncreaseSizeResponse {
    const message = createBaseNodeGroupIncreaseSizeResponse();
    return message;
  },
};

function createBaseNodeGroupDeleteNodesRequest(): NodeGroupDeleteNodesRequest {
  return { nodes: [], id: "" };
}

export const NodeGroupDeleteNodesRequest: MessageFns<NodeGroupDeleteNodesRequest> = {
  encode(message: NodeGroupDeleteNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      ExternalGrpcNode.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupDeleteNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupDeleteNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(ExternalGrpcNode.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupDeleteNodesRequest {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => ExternalGrpcNode.fromJSON(e)) : [],
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: NodeGroupDeleteNodesRequest): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => ExternalGrpcNode.toJSON(e));
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupDeleteNodesRequest>, I>>(base?: I): NodeGroupDeleteNodesRequest {
    return NodeGroupDeleteNodesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupDeleteNodesRequest>, I>>(object: I): NodeGroupDeleteNodesRequest {
    const message = createBaseNodeGroupDeleteNodesRequest();
    message.nodes = object.nodes?.map((e) => ExternalGrpcNode.fromPartial(e)) || [];
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNodeGroupDeleteNodesResponse(): NodeGroupDeleteNodesResponse {
  return {};
}

export const NodeGroupDeleteNodesResponse: MessageFns<NodeGroupDeleteNodesResponse> = {
  encode(_: NodeGroupDeleteNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupDeleteNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupDeleteNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NodeGroupDeleteNodesResponse {
    return {};
  },

  toJSON(_: NodeGroupDeleteNodesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupDeleteNodesResponse>, I>>(base?: I): NodeGroupDeleteNodesResponse {
    return NodeGroupDeleteNodesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupDeleteNodesResponse>, I>>(_: I): NodeGroupDeleteNodesResponse {
    const message = createBaseNodeGroupDeleteNodesResponse();
    return message;
  },
};

function createBaseNodeGroupDecreaseTargetSizeRequest(): NodeGroupDecreaseTargetSizeRequest {
  return { delta: 0, id: "" };
}

export const NodeGroupDecreaseTargetSizeRequest: MessageFns<NodeGroupDecreaseTargetSizeRequest> = {
  encode(message: NodeGroupDecreaseTargetSizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delta !== 0) {
      writer.uint32(8).int32(message.delta);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupDecreaseTargetSizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupDecreaseTargetSizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.delta = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupDecreaseTargetSizeRequest {
    return {
      delta: isSet(object.delta) ? globalThis.Number(object.delta) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: NodeGroupDecreaseTargetSizeRequest): unknown {
    const obj: any = {};
    if (message.delta !== 0) {
      obj.delta = Math.round(message.delta);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupDecreaseTargetSizeRequest>, I>>(
    base?: I,
  ): NodeGroupDecreaseTargetSizeRequest {
    return NodeGroupDecreaseTargetSizeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupDecreaseTargetSizeRequest>, I>>(
    object: I,
  ): NodeGroupDecreaseTargetSizeRequest {
    const message = createBaseNodeGroupDecreaseTargetSizeRequest();
    message.delta = object.delta ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNodeGroupDecreaseTargetSizeResponse(): NodeGroupDecreaseTargetSizeResponse {
  return {};
}

export const NodeGroupDecreaseTargetSizeResponse: MessageFns<NodeGroupDecreaseTargetSizeResponse> = {
  encode(_: NodeGroupDecreaseTargetSizeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupDecreaseTargetSizeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupDecreaseTargetSizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NodeGroupDecreaseTargetSizeResponse {
    return {};
  },

  toJSON(_: NodeGroupDecreaseTargetSizeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupDecreaseTargetSizeResponse>, I>>(
    base?: I,
  ): NodeGroupDecreaseTargetSizeResponse {
    return NodeGroupDecreaseTargetSizeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupDecreaseTargetSizeResponse>, I>>(
    _: I,
  ): NodeGroupDecreaseTargetSizeResponse {
    const message = createBaseNodeGroupDecreaseTargetSizeResponse();
    return message;
  },
};

function createBaseNodeGroupNodesRequest(): NodeGroupNodesRequest {
  return { id: "" };
}

export const NodeGroupNodesRequest: MessageFns<NodeGroupNodesRequest> = {
  encode(message: NodeGroupNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupNodesRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: NodeGroupNodesRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupNodesRequest>, I>>(base?: I): NodeGroupNodesRequest {
    return NodeGroupNodesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupNodesRequest>, I>>(object: I): NodeGroupNodesRequest {
    const message = createBaseNodeGroupNodesRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNodeGroupNodesResponse(): NodeGroupNodesResponse {
  return { instances: [] };
}

export const NodeGroupNodesResponse: MessageFns<NodeGroupNodesResponse> = {
  encode(message: NodeGroupNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      Instance.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instances.push(Instance.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupNodesResponse {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => Instance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NodeGroupNodesResponse): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => Instance.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupNodesResponse>, I>>(base?: I): NodeGroupNodesResponse {
    return NodeGroupNodesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupNodesResponse>, I>>(object: I): NodeGroupNodesResponse {
    const message = createBaseNodeGroupNodesResponse();
    message.instances = object.instances?.map((e) => Instance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInstance(): Instance {
  return { id: "", status: undefined };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      InstanceStatus.encode(message.status, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = InstanceStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? InstanceStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== undefined) {
      obj.status = InstanceStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance>, I>>(base?: I): Instance {
    return Instance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance>, I>>(object: I): Instance {
    const message = createBaseInstance();
    message.id = object.id ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? InstanceStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseInstanceStatus(): InstanceStatus {
  return { instanceState: 0, errorInfo: undefined };
}

export const InstanceStatus: MessageFns<InstanceStatus> = {
  encode(message: InstanceStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceState !== 0) {
      writer.uint32(8).int32(message.instanceState);
    }
    if (message.errorInfo !== undefined) {
      InstanceErrorInfo.encode(message.errorInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.instanceState = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorInfo = InstanceErrorInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceStatus {
    return {
      instanceState: isSet(object.instanceState) ? instanceStatus_InstanceStateFromJSON(object.instanceState) : 0,
      errorInfo: isSet(object.errorInfo) ? InstanceErrorInfo.fromJSON(object.errorInfo) : undefined,
    };
  },

  toJSON(message: InstanceStatus): unknown {
    const obj: any = {};
    if (message.instanceState !== 0) {
      obj.instanceState = instanceStatus_InstanceStateToJSON(message.instanceState);
    }
    if (message.errorInfo !== undefined) {
      obj.errorInfo = InstanceErrorInfo.toJSON(message.errorInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceStatus>, I>>(base?: I): InstanceStatus {
    return InstanceStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceStatus>, I>>(object: I): InstanceStatus {
    const message = createBaseInstanceStatus();
    message.instanceState = object.instanceState ?? 0;
    message.errorInfo = (object.errorInfo !== undefined && object.errorInfo !== null)
      ? InstanceErrorInfo.fromPartial(object.errorInfo)
      : undefined;
    return message;
  },
};

function createBaseInstanceErrorInfo(): InstanceErrorInfo {
  return { errorCode: "", errorMessage: "", instanceErrorClass: 0 };
}

export const InstanceErrorInfo: MessageFns<InstanceErrorInfo> = {
  encode(message: InstanceErrorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.instanceErrorClass !== 0) {
      writer.uint32(24).int32(message.instanceErrorClass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceErrorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceErrorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.instanceErrorClass = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceErrorInfo {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      instanceErrorClass: isSet(object.instanceErrorClass) ? globalThis.Number(object.instanceErrorClass) : 0,
    };
  },

  toJSON(message: InstanceErrorInfo): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.instanceErrorClass !== 0) {
      obj.instanceErrorClass = Math.round(message.instanceErrorClass);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceErrorInfo>, I>>(base?: I): InstanceErrorInfo {
    return InstanceErrorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceErrorInfo>, I>>(object: I): InstanceErrorInfo {
    const message = createBaseInstanceErrorInfo();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.instanceErrorClass = object.instanceErrorClass ?? 0;
    return message;
  },
};

function createBaseNodeGroupTemplateNodeInfoRequest(): NodeGroupTemplateNodeInfoRequest {
  return { id: "" };
}

export const NodeGroupTemplateNodeInfoRequest: MessageFns<NodeGroupTemplateNodeInfoRequest> = {
  encode(message: NodeGroupTemplateNodeInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupTemplateNodeInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupTemplateNodeInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupTemplateNodeInfoRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: NodeGroupTemplateNodeInfoRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupTemplateNodeInfoRequest>, I>>(
    base?: I,
  ): NodeGroupTemplateNodeInfoRequest {
    return NodeGroupTemplateNodeInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupTemplateNodeInfoRequest>, I>>(
    object: I,
  ): NodeGroupTemplateNodeInfoRequest {
    const message = createBaseNodeGroupTemplateNodeInfoRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNodeGroupTemplateNodeInfoResponse(): NodeGroupTemplateNodeInfoResponse {
  return { nodeInfo: undefined };
}

export const NodeGroupTemplateNodeInfoResponse: MessageFns<NodeGroupTemplateNodeInfoResponse> = {
  encode(message: NodeGroupTemplateNodeInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeInfo !== undefined) {
      Node.encode(message.nodeInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupTemplateNodeInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupTemplateNodeInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeInfo = Node.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupTemplateNodeInfoResponse {
    return { nodeInfo: isSet(object.nodeInfo) ? Node.fromJSON(object.nodeInfo) : undefined };
  },

  toJSON(message: NodeGroupTemplateNodeInfoResponse): unknown {
    const obj: any = {};
    if (message.nodeInfo !== undefined) {
      obj.nodeInfo = Node.toJSON(message.nodeInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupTemplateNodeInfoResponse>, I>>(
    base?: I,
  ): NodeGroupTemplateNodeInfoResponse {
    return NodeGroupTemplateNodeInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupTemplateNodeInfoResponse>, I>>(
    object: I,
  ): NodeGroupTemplateNodeInfoResponse {
    const message = createBaseNodeGroupTemplateNodeInfoResponse();
    message.nodeInfo = (object.nodeInfo !== undefined && object.nodeInfo !== null)
      ? Node.fromPartial(object.nodeInfo)
      : undefined;
    return message;
  },
};

function createBaseNodeGroupAutoscalingOptions(): NodeGroupAutoscalingOptions {
  return {
    scaleDownUtilizationThreshold: 0,
    scaleDownGpuUtilizationThreshold: 0,
    scaleDownUnneededTime: undefined,
    scaleDownUnreadyTime: undefined,
    MaxNodeProvisionTime: undefined,
    zeroOrMaxNodeScaling: false,
    ignoreDaemonSetsUtilization: false,
  };
}

export const NodeGroupAutoscalingOptions: MessageFns<NodeGroupAutoscalingOptions> = {
  encode(message: NodeGroupAutoscalingOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scaleDownUtilizationThreshold !== 0) {
      writer.uint32(9).double(message.scaleDownUtilizationThreshold);
    }
    if (message.scaleDownGpuUtilizationThreshold !== 0) {
      writer.uint32(17).double(message.scaleDownGpuUtilizationThreshold);
    }
    if (message.scaleDownUnneededTime !== undefined) {
      Duration.encode(message.scaleDownUnneededTime, writer.uint32(26).fork()).join();
    }
    if (message.scaleDownUnreadyTime !== undefined) {
      Duration.encode(message.scaleDownUnreadyTime, writer.uint32(34).fork()).join();
    }
    if (message.MaxNodeProvisionTime !== undefined) {
      Duration.encode(message.MaxNodeProvisionTime, writer.uint32(42).fork()).join();
    }
    if (message.zeroOrMaxNodeScaling !== false) {
      writer.uint32(48).bool(message.zeroOrMaxNodeScaling);
    }
    if (message.ignoreDaemonSetsUtilization !== false) {
      writer.uint32(56).bool(message.ignoreDaemonSetsUtilization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupAutoscalingOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupAutoscalingOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.scaleDownUtilizationThreshold = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.scaleDownGpuUtilizationThreshold = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scaleDownUnneededTime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scaleDownUnreadyTime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.MaxNodeProvisionTime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.zeroOrMaxNodeScaling = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ignoreDaemonSetsUtilization = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupAutoscalingOptions {
    return {
      scaleDownUtilizationThreshold: isSet(object.scaleDownUtilizationThreshold)
        ? globalThis.Number(object.scaleDownUtilizationThreshold)
        : 0,
      scaleDownGpuUtilizationThreshold: isSet(object.scaleDownGpuUtilizationThreshold)
        ? globalThis.Number(object.scaleDownGpuUtilizationThreshold)
        : 0,
      scaleDownUnneededTime: isSet(object.scaleDownUnneededTime)
        ? Duration.fromJSON(object.scaleDownUnneededTime)
        : undefined,
      scaleDownUnreadyTime: isSet(object.scaleDownUnreadyTime)
        ? Duration.fromJSON(object.scaleDownUnreadyTime)
        : undefined,
      MaxNodeProvisionTime: isSet(object.MaxNodeProvisionTime)
        ? Duration.fromJSON(object.MaxNodeProvisionTime)
        : undefined,
      zeroOrMaxNodeScaling: isSet(object.zeroOrMaxNodeScaling)
        ? globalThis.Boolean(object.zeroOrMaxNodeScaling)
        : false,
      ignoreDaemonSetsUtilization: isSet(object.ignoreDaemonSetsUtilization)
        ? globalThis.Boolean(object.ignoreDaemonSetsUtilization)
        : false,
    };
  },

  toJSON(message: NodeGroupAutoscalingOptions): unknown {
    const obj: any = {};
    if (message.scaleDownUtilizationThreshold !== 0) {
      obj.scaleDownUtilizationThreshold = message.scaleDownUtilizationThreshold;
    }
    if (message.scaleDownGpuUtilizationThreshold !== 0) {
      obj.scaleDownGpuUtilizationThreshold = message.scaleDownGpuUtilizationThreshold;
    }
    if (message.scaleDownUnneededTime !== undefined) {
      obj.scaleDownUnneededTime = Duration.toJSON(message.scaleDownUnneededTime);
    }
    if (message.scaleDownUnreadyTime !== undefined) {
      obj.scaleDownUnreadyTime = Duration.toJSON(message.scaleDownUnreadyTime);
    }
    if (message.MaxNodeProvisionTime !== undefined) {
      obj.MaxNodeProvisionTime = Duration.toJSON(message.MaxNodeProvisionTime);
    }
    if (message.zeroOrMaxNodeScaling !== false) {
      obj.zeroOrMaxNodeScaling = message.zeroOrMaxNodeScaling;
    }
    if (message.ignoreDaemonSetsUtilization !== false) {
      obj.ignoreDaemonSetsUtilization = message.ignoreDaemonSetsUtilization;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupAutoscalingOptions>, I>>(base?: I): NodeGroupAutoscalingOptions {
    return NodeGroupAutoscalingOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupAutoscalingOptions>, I>>(object: I): NodeGroupAutoscalingOptions {
    const message = createBaseNodeGroupAutoscalingOptions();
    message.scaleDownUtilizationThreshold = object.scaleDownUtilizationThreshold ?? 0;
    message.scaleDownGpuUtilizationThreshold = object.scaleDownGpuUtilizationThreshold ?? 0;
    message.scaleDownUnneededTime =
      (object.scaleDownUnneededTime !== undefined && object.scaleDownUnneededTime !== null)
        ? Duration.fromPartial(object.scaleDownUnneededTime)
        : undefined;
    message.scaleDownUnreadyTime = (object.scaleDownUnreadyTime !== undefined && object.scaleDownUnreadyTime !== null)
      ? Duration.fromPartial(object.scaleDownUnreadyTime)
      : undefined;
    message.MaxNodeProvisionTime = (object.MaxNodeProvisionTime !== undefined && object.MaxNodeProvisionTime !== null)
      ? Duration.fromPartial(object.MaxNodeProvisionTime)
      : undefined;
    message.zeroOrMaxNodeScaling = object.zeroOrMaxNodeScaling ?? false;
    message.ignoreDaemonSetsUtilization = object.ignoreDaemonSetsUtilization ?? false;
    return message;
  },
};

function createBaseNodeGroupAutoscalingOptionsRequest(): NodeGroupAutoscalingOptionsRequest {
  return { id: "", defaults: undefined };
}

export const NodeGroupAutoscalingOptionsRequest: MessageFns<NodeGroupAutoscalingOptionsRequest> = {
  encode(message: NodeGroupAutoscalingOptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.defaults !== undefined) {
      NodeGroupAutoscalingOptions.encode(message.defaults, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupAutoscalingOptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupAutoscalingOptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaults = NodeGroupAutoscalingOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupAutoscalingOptionsRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      defaults: isSet(object.defaults) ? NodeGroupAutoscalingOptions.fromJSON(object.defaults) : undefined,
    };
  },

  toJSON(message: NodeGroupAutoscalingOptionsRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.defaults !== undefined) {
      obj.defaults = NodeGroupAutoscalingOptions.toJSON(message.defaults);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupAutoscalingOptionsRequest>, I>>(
    base?: I,
  ): NodeGroupAutoscalingOptionsRequest {
    return NodeGroupAutoscalingOptionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupAutoscalingOptionsRequest>, I>>(
    object: I,
  ): NodeGroupAutoscalingOptionsRequest {
    const message = createBaseNodeGroupAutoscalingOptionsRequest();
    message.id = object.id ?? "";
    message.defaults = (object.defaults !== undefined && object.defaults !== null)
      ? NodeGroupAutoscalingOptions.fromPartial(object.defaults)
      : undefined;
    return message;
  },
};

function createBaseNodeGroupAutoscalingOptionsResponse(): NodeGroupAutoscalingOptionsResponse {
  return { nodeGroupAutoscalingOptions: undefined };
}

export const NodeGroupAutoscalingOptionsResponse: MessageFns<NodeGroupAutoscalingOptionsResponse> = {
  encode(message: NodeGroupAutoscalingOptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeGroupAutoscalingOptions !== undefined) {
      NodeGroupAutoscalingOptions.encode(message.nodeGroupAutoscalingOptions, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGroupAutoscalingOptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGroupAutoscalingOptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeGroupAutoscalingOptions = NodeGroupAutoscalingOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGroupAutoscalingOptionsResponse {
    return {
      nodeGroupAutoscalingOptions: isSet(object.nodeGroupAutoscalingOptions)
        ? NodeGroupAutoscalingOptions.fromJSON(object.nodeGroupAutoscalingOptions)
        : undefined,
    };
  },

  toJSON(message: NodeGroupAutoscalingOptionsResponse): unknown {
    const obj: any = {};
    if (message.nodeGroupAutoscalingOptions !== undefined) {
      obj.nodeGroupAutoscalingOptions = NodeGroupAutoscalingOptions.toJSON(message.nodeGroupAutoscalingOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGroupAutoscalingOptionsResponse>, I>>(
    base?: I,
  ): NodeGroupAutoscalingOptionsResponse {
    return NodeGroupAutoscalingOptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGroupAutoscalingOptionsResponse>, I>>(
    object: I,
  ): NodeGroupAutoscalingOptionsResponse {
    const message = createBaseNodeGroupAutoscalingOptionsResponse();
    message.nodeGroupAutoscalingOptions =
      (object.nodeGroupAutoscalingOptions !== undefined && object.nodeGroupAutoscalingOptions !== null)
        ? NodeGroupAutoscalingOptions.fromPartial(object.nodeGroupAutoscalingOptions)
        : undefined;
    return message;
  },
};

/** CloudProvider specific RPC functions */
export type CloudProviderService = typeof CloudProviderService;
export const CloudProviderService = {
  /** NodeGroups returns all node groups configured for this cloud provider. */
  nodeGroups: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroups",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NodeGroupsRequest): Buffer => Buffer.from(NodeGroupsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NodeGroupsRequest => NodeGroupsRequest.decode(value),
    responseSerialize: (value: NodeGroupsResponse): Buffer => Buffer.from(NodeGroupsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NodeGroupsResponse => NodeGroupsResponse.decode(value),
  },
  /**
   * NodeGroupForNode returns the node group for the given node.
   * The node group id is an empty string if the node should not
   * be processed by cluster autoscaler.
   */
  nodeGroupForNode: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroupForNode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NodeGroupForNodeRequest): Buffer =>
      Buffer.from(NodeGroupForNodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NodeGroupForNodeRequest => NodeGroupForNodeRequest.decode(value),
    responseSerialize: (value: NodeGroupForNodeResponse): Buffer =>
      Buffer.from(NodeGroupForNodeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NodeGroupForNodeResponse => NodeGroupForNodeResponse.decode(value),
  },
  /**
   * PricingNodePrice returns a theoretical minimum price of running a node for
   * a given period of time on a perfectly matching machine.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  pricingNodePrice: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/PricingNodePrice",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PricingNodePriceRequest): Buffer =>
      Buffer.from(PricingNodePriceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PricingNodePriceRequest => PricingNodePriceRequest.decode(value),
    responseSerialize: (value: PricingNodePriceResponse): Buffer =>
      Buffer.from(PricingNodePriceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PricingNodePriceResponse => PricingNodePriceResponse.decode(value),
  },
  /**
   * PricingPodPrice returns a theoretical minimum price of running a pod for a given
   * period of time on a perfectly matching machine.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  pricingPodPrice: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/PricingPodPrice",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PricingPodPriceRequest): Buffer =>
      Buffer.from(PricingPodPriceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PricingPodPriceRequest => PricingPodPriceRequest.decode(value),
    responseSerialize: (value: PricingPodPriceResponse): Buffer =>
      Buffer.from(PricingPodPriceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PricingPodPriceResponse => PricingPodPriceResponse.decode(value),
  },
  /** GPULabel returns the label added to nodes with GPU resource. */
  gpuLabel: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/GPULabel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GPULabelRequest): Buffer => Buffer.from(GPULabelRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GPULabelRequest => GPULabelRequest.decode(value),
    responseSerialize: (value: GPULabelResponse): Buffer => Buffer.from(GPULabelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GPULabelResponse => GPULabelResponse.decode(value),
  },
  /** GetAvailableGPUTypes return all available GPU types cloud provider supports. */
  getAvailableGpuTypes: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/GetAvailableGPUTypes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAvailableGPUTypesRequest): Buffer =>
      Buffer.from(GetAvailableGPUTypesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAvailableGPUTypesRequest => GetAvailableGPUTypesRequest.decode(value),
    responseSerialize: (value: GetAvailableGPUTypesResponse): Buffer =>
      Buffer.from(GetAvailableGPUTypesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetAvailableGPUTypesResponse => GetAvailableGPUTypesResponse.decode(value),
  },
  /** Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc. */
  cleanup: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/Cleanup",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CleanupRequest): Buffer => Buffer.from(CleanupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CleanupRequest => CleanupRequest.decode(value),
    responseSerialize: (value: CleanupResponse): Buffer => Buffer.from(CleanupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CleanupResponse => CleanupResponse.decode(value),
  },
  /** Refresh is called before every main loop and can be used to dynamically update cloud provider state. */
  refresh: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/Refresh",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshRequest): Buffer => Buffer.from(RefreshRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshRequest => RefreshRequest.decode(value),
    responseSerialize: (value: RefreshResponse): Buffer => Buffer.from(RefreshResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RefreshResponse => RefreshResponse.decode(value),
  },
  /**
   * NodeGroupTargetSize returns the current target size of the node group. It is possible
   * that the number of nodes in Kubernetes is different at the moment but should be equal
   * to the size of a node group once everything stabilizes (new nodes finish startup and
   * registration or removed nodes are deleted completely).
   */
  nodeGroupTargetSize: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroupTargetSize",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NodeGroupTargetSizeRequest): Buffer =>
      Buffer.from(NodeGroupTargetSizeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NodeGroupTargetSizeRequest => NodeGroupTargetSizeRequest.decode(value),
    responseSerialize: (value: NodeGroupTargetSizeResponse): Buffer =>
      Buffer.from(NodeGroupTargetSizeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NodeGroupTargetSizeResponse => NodeGroupTargetSizeResponse.decode(value),
  },
  /**
   * NodeGroupIncreaseSize increases the size of the node group. To delete a node you need
   * to explicitly name it and use NodeGroupDeleteNodes. This function should wait until
   * node group size is updated.
   */
  nodeGroupIncreaseSize: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroupIncreaseSize",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NodeGroupIncreaseSizeRequest): Buffer =>
      Buffer.from(NodeGroupIncreaseSizeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NodeGroupIncreaseSizeRequest => NodeGroupIncreaseSizeRequest.decode(value),
    responseSerialize: (value: NodeGroupIncreaseSizeResponse): Buffer =>
      Buffer.from(NodeGroupIncreaseSizeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NodeGroupIncreaseSizeResponse => NodeGroupIncreaseSizeResponse.decode(value),
  },
  /**
   * NodeGroupDeleteNodes deletes nodes from this node group (and also decreasing the size
   * of the node group with that). Error is returned either on failure or if the given node
   * doesn't belong to this node group. This function should wait until node group size is updated.
   */
  nodeGroupDeleteNodes: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroupDeleteNodes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NodeGroupDeleteNodesRequest): Buffer =>
      Buffer.from(NodeGroupDeleteNodesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NodeGroupDeleteNodesRequest => NodeGroupDeleteNodesRequest.decode(value),
    responseSerialize: (value: NodeGroupDeleteNodesResponse): Buffer =>
      Buffer.from(NodeGroupDeleteNodesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NodeGroupDeleteNodesResponse => NodeGroupDeleteNodesResponse.decode(value),
  },
  /**
   * NodeGroupDecreaseTargetSize decreases the target size of the node group. This function
   * doesn't permit to delete any existing node and can be used only to reduce the request
   * for new nodes that have not been yet fulfilled. Delta should be negative. It is assumed
   * that cloud provider will not delete the existing nodes if the size when there is an option
   * to just decrease the target.
   */
  nodeGroupDecreaseTargetSize: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroupDecreaseTargetSize",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NodeGroupDecreaseTargetSizeRequest): Buffer =>
      Buffer.from(NodeGroupDecreaseTargetSizeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NodeGroupDecreaseTargetSizeRequest =>
      NodeGroupDecreaseTargetSizeRequest.decode(value),
    responseSerialize: (value: NodeGroupDecreaseTargetSizeResponse): Buffer =>
      Buffer.from(NodeGroupDecreaseTargetSizeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NodeGroupDecreaseTargetSizeResponse =>
      NodeGroupDecreaseTargetSizeResponse.decode(value),
  },
  /** NodeGroupNodes returns a list of all nodes that belong to this node group. */
  nodeGroupNodes: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroupNodes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NodeGroupNodesRequest): Buffer =>
      Buffer.from(NodeGroupNodesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NodeGroupNodesRequest => NodeGroupNodesRequest.decode(value),
    responseSerialize: (value: NodeGroupNodesResponse): Buffer =>
      Buffer.from(NodeGroupNodesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NodeGroupNodesResponse => NodeGroupNodesResponse.decode(value),
  },
  /**
   * NodeGroupTemplateNodeInfo returns a structure of an empty (as if just started) node,
   * with all of the labels, capacity and allocatable information. This will be used in
   * scale-up simulations to predict what would a new node look like if a node group was expanded.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  nodeGroupTemplateNodeInfo: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroupTemplateNodeInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NodeGroupTemplateNodeInfoRequest): Buffer =>
      Buffer.from(NodeGroupTemplateNodeInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NodeGroupTemplateNodeInfoRequest =>
      NodeGroupTemplateNodeInfoRequest.decode(value),
    responseSerialize: (value: NodeGroupTemplateNodeInfoResponse): Buffer =>
      Buffer.from(NodeGroupTemplateNodeInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NodeGroupTemplateNodeInfoResponse =>
      NodeGroupTemplateNodeInfoResponse.decode(value),
  },
  /**
   * GetOptions returns NodeGroupAutoscalingOptions that should be used for this particular
   * NodeGroup.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  nodeGroupGetOptions: {
    path: "/clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroupGetOptions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NodeGroupAutoscalingOptionsRequest): Buffer =>
      Buffer.from(NodeGroupAutoscalingOptionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NodeGroupAutoscalingOptionsRequest =>
      NodeGroupAutoscalingOptionsRequest.decode(value),
    responseSerialize: (value: NodeGroupAutoscalingOptionsResponse): Buffer =>
      Buffer.from(NodeGroupAutoscalingOptionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NodeGroupAutoscalingOptionsResponse =>
      NodeGroupAutoscalingOptionsResponse.decode(value),
  },
} as const;

export interface CloudProviderServer extends UntypedServiceImplementation {
  /** NodeGroups returns all node groups configured for this cloud provider. */
  nodeGroups: handleUnaryCall<NodeGroupsRequest, NodeGroupsResponse>;
  /**
   * NodeGroupForNode returns the node group for the given node.
   * The node group id is an empty string if the node should not
   * be processed by cluster autoscaler.
   */
  nodeGroupForNode: handleUnaryCall<NodeGroupForNodeRequest, NodeGroupForNodeResponse>;
  /**
   * PricingNodePrice returns a theoretical minimum price of running a node for
   * a given period of time on a perfectly matching machine.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  pricingNodePrice: handleUnaryCall<PricingNodePriceRequest, PricingNodePriceResponse>;
  /**
   * PricingPodPrice returns a theoretical minimum price of running a pod for a given
   * period of time on a perfectly matching machine.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  pricingPodPrice: handleUnaryCall<PricingPodPriceRequest, PricingPodPriceResponse>;
  /** GPULabel returns the label added to nodes with GPU resource. */
  gpuLabel: handleUnaryCall<GPULabelRequest, GPULabelResponse>;
  /** GetAvailableGPUTypes return all available GPU types cloud provider supports. */
  getAvailableGpuTypes: handleUnaryCall<GetAvailableGPUTypesRequest, GetAvailableGPUTypesResponse>;
  /** Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc. */
  cleanup: handleUnaryCall<CleanupRequest, CleanupResponse>;
  /** Refresh is called before every main loop and can be used to dynamically update cloud provider state. */
  refresh: handleUnaryCall<RefreshRequest, RefreshResponse>;
  /**
   * NodeGroupTargetSize returns the current target size of the node group. It is possible
   * that the number of nodes in Kubernetes is different at the moment but should be equal
   * to the size of a node group once everything stabilizes (new nodes finish startup and
   * registration or removed nodes are deleted completely).
   */
  nodeGroupTargetSize: handleUnaryCall<NodeGroupTargetSizeRequest, NodeGroupTargetSizeResponse>;
  /**
   * NodeGroupIncreaseSize increases the size of the node group. To delete a node you need
   * to explicitly name it and use NodeGroupDeleteNodes. This function should wait until
   * node group size is updated.
   */
  nodeGroupIncreaseSize: handleUnaryCall<NodeGroupIncreaseSizeRequest, NodeGroupIncreaseSizeResponse>;
  /**
   * NodeGroupDeleteNodes deletes nodes from this node group (and also decreasing the size
   * of the node group with that). Error is returned either on failure or if the given node
   * doesn't belong to this node group. This function should wait until node group size is updated.
   */
  nodeGroupDeleteNodes: handleUnaryCall<NodeGroupDeleteNodesRequest, NodeGroupDeleteNodesResponse>;
  /**
   * NodeGroupDecreaseTargetSize decreases the target size of the node group. This function
   * doesn't permit to delete any existing node and can be used only to reduce the request
   * for new nodes that have not been yet fulfilled. Delta should be negative. It is assumed
   * that cloud provider will not delete the existing nodes if the size when there is an option
   * to just decrease the target.
   */
  nodeGroupDecreaseTargetSize: handleUnaryCall<NodeGroupDecreaseTargetSizeRequest, NodeGroupDecreaseTargetSizeResponse>;
  /** NodeGroupNodes returns a list of all nodes that belong to this node group. */
  nodeGroupNodes: handleUnaryCall<NodeGroupNodesRequest, NodeGroupNodesResponse>;
  /**
   * NodeGroupTemplateNodeInfo returns a structure of an empty (as if just started) node,
   * with all of the labels, capacity and allocatable information. This will be used in
   * scale-up simulations to predict what would a new node look like if a node group was expanded.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  nodeGroupTemplateNodeInfo: handleUnaryCall<NodeGroupTemplateNodeInfoRequest, NodeGroupTemplateNodeInfoResponse>;
  /**
   * GetOptions returns NodeGroupAutoscalingOptions that should be used for this particular
   * NodeGroup.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  nodeGroupGetOptions: handleUnaryCall<NodeGroupAutoscalingOptionsRequest, NodeGroupAutoscalingOptionsResponse>;
}

export interface CloudProviderClient extends Client {
  /** NodeGroups returns all node groups configured for this cloud provider. */
  nodeGroups(
    request: NodeGroupsRequest,
    callback: (error: ServiceError | null, response: NodeGroupsResponse) => void,
  ): ClientUnaryCall;
  nodeGroups(
    request: NodeGroupsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeGroupsResponse) => void,
  ): ClientUnaryCall;
  nodeGroups(
    request: NodeGroupsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeGroupsResponse) => void,
  ): ClientUnaryCall;
  /**
   * NodeGroupForNode returns the node group for the given node.
   * The node group id is an empty string if the node should not
   * be processed by cluster autoscaler.
   */
  nodeGroupForNode(
    request: NodeGroupForNodeRequest,
    callback: (error: ServiceError | null, response: NodeGroupForNodeResponse) => void,
  ): ClientUnaryCall;
  nodeGroupForNode(
    request: NodeGroupForNodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeGroupForNodeResponse) => void,
  ): ClientUnaryCall;
  nodeGroupForNode(
    request: NodeGroupForNodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeGroupForNodeResponse) => void,
  ): ClientUnaryCall;
  /**
   * PricingNodePrice returns a theoretical minimum price of running a node for
   * a given period of time on a perfectly matching machine.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  pricingNodePrice(
    request: PricingNodePriceRequest,
    callback: (error: ServiceError | null, response: PricingNodePriceResponse) => void,
  ): ClientUnaryCall;
  pricingNodePrice(
    request: PricingNodePriceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PricingNodePriceResponse) => void,
  ): ClientUnaryCall;
  pricingNodePrice(
    request: PricingNodePriceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PricingNodePriceResponse) => void,
  ): ClientUnaryCall;
  /**
   * PricingPodPrice returns a theoretical minimum price of running a pod for a given
   * period of time on a perfectly matching machine.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  pricingPodPrice(
    request: PricingPodPriceRequest,
    callback: (error: ServiceError | null, response: PricingPodPriceResponse) => void,
  ): ClientUnaryCall;
  pricingPodPrice(
    request: PricingPodPriceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PricingPodPriceResponse) => void,
  ): ClientUnaryCall;
  pricingPodPrice(
    request: PricingPodPriceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PricingPodPriceResponse) => void,
  ): ClientUnaryCall;
  /** GPULabel returns the label added to nodes with GPU resource. */
  gpuLabel(
    request: GPULabelRequest,
    callback: (error: ServiceError | null, response: GPULabelResponse) => void,
  ): ClientUnaryCall;
  gpuLabel(
    request: GPULabelRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GPULabelResponse) => void,
  ): ClientUnaryCall;
  gpuLabel(
    request: GPULabelRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GPULabelResponse) => void,
  ): ClientUnaryCall;
  /** GetAvailableGPUTypes return all available GPU types cloud provider supports. */
  getAvailableGpuTypes(
    request: GetAvailableGPUTypesRequest,
    callback: (error: ServiceError | null, response: GetAvailableGPUTypesResponse) => void,
  ): ClientUnaryCall;
  getAvailableGpuTypes(
    request: GetAvailableGPUTypesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAvailableGPUTypesResponse) => void,
  ): ClientUnaryCall;
  getAvailableGpuTypes(
    request: GetAvailableGPUTypesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAvailableGPUTypesResponse) => void,
  ): ClientUnaryCall;
  /** Cleanup cleans up open resources before the cloud provider is destroyed, i.e. go routines etc. */
  cleanup(
    request: CleanupRequest,
    callback: (error: ServiceError | null, response: CleanupResponse) => void,
  ): ClientUnaryCall;
  cleanup(
    request: CleanupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CleanupResponse) => void,
  ): ClientUnaryCall;
  cleanup(
    request: CleanupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CleanupResponse) => void,
  ): ClientUnaryCall;
  /** Refresh is called before every main loop and can be used to dynamically update cloud provider state. */
  refresh(
    request: RefreshRequest,
    callback: (error: ServiceError | null, response: RefreshResponse) => void,
  ): ClientUnaryCall;
  refresh(
    request: RefreshRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefreshResponse) => void,
  ): ClientUnaryCall;
  refresh(
    request: RefreshRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefreshResponse) => void,
  ): ClientUnaryCall;
  /**
   * NodeGroupTargetSize returns the current target size of the node group. It is possible
   * that the number of nodes in Kubernetes is different at the moment but should be equal
   * to the size of a node group once everything stabilizes (new nodes finish startup and
   * registration or removed nodes are deleted completely).
   */
  nodeGroupTargetSize(
    request: NodeGroupTargetSizeRequest,
    callback: (error: ServiceError | null, response: NodeGroupTargetSizeResponse) => void,
  ): ClientUnaryCall;
  nodeGroupTargetSize(
    request: NodeGroupTargetSizeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeGroupTargetSizeResponse) => void,
  ): ClientUnaryCall;
  nodeGroupTargetSize(
    request: NodeGroupTargetSizeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeGroupTargetSizeResponse) => void,
  ): ClientUnaryCall;
  /**
   * NodeGroupIncreaseSize increases the size of the node group. To delete a node you need
   * to explicitly name it and use NodeGroupDeleteNodes. This function should wait until
   * node group size is updated.
   */
  nodeGroupIncreaseSize(
    request: NodeGroupIncreaseSizeRequest,
    callback: (error: ServiceError | null, response: NodeGroupIncreaseSizeResponse) => void,
  ): ClientUnaryCall;
  nodeGroupIncreaseSize(
    request: NodeGroupIncreaseSizeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeGroupIncreaseSizeResponse) => void,
  ): ClientUnaryCall;
  nodeGroupIncreaseSize(
    request: NodeGroupIncreaseSizeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeGroupIncreaseSizeResponse) => void,
  ): ClientUnaryCall;
  /**
   * NodeGroupDeleteNodes deletes nodes from this node group (and also decreasing the size
   * of the node group with that). Error is returned either on failure or if the given node
   * doesn't belong to this node group. This function should wait until node group size is updated.
   */
  nodeGroupDeleteNodes(
    request: NodeGroupDeleteNodesRequest,
    callback: (error: ServiceError | null, response: NodeGroupDeleteNodesResponse) => void,
  ): ClientUnaryCall;
  nodeGroupDeleteNodes(
    request: NodeGroupDeleteNodesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeGroupDeleteNodesResponse) => void,
  ): ClientUnaryCall;
  nodeGroupDeleteNodes(
    request: NodeGroupDeleteNodesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeGroupDeleteNodesResponse) => void,
  ): ClientUnaryCall;
  /**
   * NodeGroupDecreaseTargetSize decreases the target size of the node group. This function
   * doesn't permit to delete any existing node and can be used only to reduce the request
   * for new nodes that have not been yet fulfilled. Delta should be negative. It is assumed
   * that cloud provider will not delete the existing nodes if the size when there is an option
   * to just decrease the target.
   */
  nodeGroupDecreaseTargetSize(
    request: NodeGroupDecreaseTargetSizeRequest,
    callback: (error: ServiceError | null, response: NodeGroupDecreaseTargetSizeResponse) => void,
  ): ClientUnaryCall;
  nodeGroupDecreaseTargetSize(
    request: NodeGroupDecreaseTargetSizeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeGroupDecreaseTargetSizeResponse) => void,
  ): ClientUnaryCall;
  nodeGroupDecreaseTargetSize(
    request: NodeGroupDecreaseTargetSizeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeGroupDecreaseTargetSizeResponse) => void,
  ): ClientUnaryCall;
  /** NodeGroupNodes returns a list of all nodes that belong to this node group. */
  nodeGroupNodes(
    request: NodeGroupNodesRequest,
    callback: (error: ServiceError | null, response: NodeGroupNodesResponse) => void,
  ): ClientUnaryCall;
  nodeGroupNodes(
    request: NodeGroupNodesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeGroupNodesResponse) => void,
  ): ClientUnaryCall;
  nodeGroupNodes(
    request: NodeGroupNodesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeGroupNodesResponse) => void,
  ): ClientUnaryCall;
  /**
   * NodeGroupTemplateNodeInfo returns a structure of an empty (as if just started) node,
   * with all of the labels, capacity and allocatable information. This will be used in
   * scale-up simulations to predict what would a new node look like if a node group was expanded.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  nodeGroupTemplateNodeInfo(
    request: NodeGroupTemplateNodeInfoRequest,
    callback: (error: ServiceError | null, response: NodeGroupTemplateNodeInfoResponse) => void,
  ): ClientUnaryCall;
  nodeGroupTemplateNodeInfo(
    request: NodeGroupTemplateNodeInfoRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeGroupTemplateNodeInfoResponse) => void,
  ): ClientUnaryCall;
  nodeGroupTemplateNodeInfo(
    request: NodeGroupTemplateNodeInfoRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeGroupTemplateNodeInfoResponse) => void,
  ): ClientUnaryCall;
  /**
   * GetOptions returns NodeGroupAutoscalingOptions that should be used for this particular
   * NodeGroup.
   * Implementation optional: if unimplemented return error code 12 (for `Unimplemented`)
   */
  nodeGroupGetOptions(
    request: NodeGroupAutoscalingOptionsRequest,
    callback: (error: ServiceError | null, response: NodeGroupAutoscalingOptionsResponse) => void,
  ): ClientUnaryCall;
  nodeGroupGetOptions(
    request: NodeGroupAutoscalingOptionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeGroupAutoscalingOptionsResponse) => void,
  ): ClientUnaryCall;
  nodeGroupGetOptions(
    request: NodeGroupAutoscalingOptionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeGroupAutoscalingOptionsResponse) => void,
  ): ClientUnaryCall;
}

export const CloudProviderClient = makeGenericClientConstructor(
  CloudProviderService,
  "clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CloudProviderClient;
  service: typeof CloudProviderService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
